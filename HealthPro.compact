pragma language_version >= 0.16.0 && <= 0.17;

//*//////////////////////////////////////////////////////////////////////////
//                                  IMPORTS
//////////////////////////////////////////////////////////////////////////*//

import CompactStandardLibrary;

import "./compact-contracts/node_modules/@openzeppelin-compact/contracts/src/access/AccessControl"
    prefix AccessControl_;

import "./compact-contracts/node_modules/@openzeppelin-compact/contracts/src/security/Pausable"
    prefix Pausable_;

import "./compact-contracts/node_modules/@openzeppelin-compact/contracts/src/utils/Utils"
    prefix Utils_;

//*//////////////////////////////////////////////////////////////////////////
//                             STRUCT DEFINITIONS
//////////////////////////////////////////////////////////////////////////*//

export struct RecordMeta {
  createdAt: Uint<64>,
  updatedAt: Uint<64>,
  version: Uint<32>,
  recordType: RecordType,
  isEncrypted: Boolean
}

export struct DelegateInfo {
  grantedBy: ZswapCoinPublicKey,
  grantedAt: Uint<64>,
  expiresAt: Uint<64>,
  accessLevel: AccessLevel
}

export enum AccountType {
  PROVIDER,
  PATIENT,
  DELEGATE,
  AUDITOR
}

export enum RecordType {
  MEDICAL_HISTORY,
  PRESCRIPTION,
  LAB_RESULT,
  IMAGING,
  CONSULTATION_NOTE,
  VACCINATION,
  ALLERGY,
  EMERGENCY_INFO
}

export enum AccessLevel {
  READ_ONLY,
  READ_WRITE,
  EMERGENCY,
  FULL
}

export enum AuditAction {
  RECORD_CREATED,
  RECORD_UPDATED,
  RECORD_ACCESSED,
  ACCESS_GRANTED,
  ACCESS_REVOKED,
  PROVIDER_ADDED,
  PROVIDER_REMOVED
}

//*//////////////////////////////////////////////////////////////////////////
//                              ROLE DEFINITIONS
//////////////////////////////////////////////////////////////////////////*//

export sealed ledger PROVIDER_ROLE: Bytes<32>;

export sealed ledger PATIENT_ROLE: Bytes<32>;

export sealed ledger DELEGATE_ROLE: Bytes<32>;

export sealed ledger AUDITOR_ROLE: Bytes<32>;

//*//////////////////////////////////////////////////////////////////////////
//                                  STORAGE
//////////////////////////////////////////////////////////////////////////*//

export ledger registeredPatients: Set<ZswapCoinPublicKey>;

export ledger registeredProviders: Set<ZswapCoinPublicKey>;

export ledger healthRecords: Map<ZswapCoinPublicKey, Opaque<"string">>;

export ledger commitments: Map<ZswapCoinPublicKey, Bytes<32>>; // maps user public key to their commitment hash

//*//////////////////////////////////////////////////////////////////////////
//                                CONSTRUCTOR
//////////////////////////////////////////////////////////////////////////*//

constructor(_initOwner: Either<ZswapCoinPublicKey, ContractAddress>) {
  AccessControl__grantRole(AccessControl_DEFAULT_ADMIN_ROLE, _initOwner);
  PROVIDER_ROLE = persistentHash<Bytes<32>>(pad(32, "PROVIDER_ROLE"));
  PATIENT_ROLE = persistentHash<Bytes<32>>(pad(32, "PATIENT_ROLE"));
  DELEGATE_ROLE = persistentHash<Bytes<32>>(pad(32, "DELEGATE_ROLE"));
  AUDITOR_ROLE = persistentHash<Bytes<32>>(pad(32, "AUDITOR_ROLE"));
}

//*//////////////////////////////////////////////////////////////////////////
//                             WITNESS FUNCTIONS
//////////////////////////////////////////////////////////////////////////*//

witness generate_private_key(account: Uint<32>): Bytes<32>;

witness reveal_private_key(account: Uint<32>): Bytes<32>;

//*//////////////////////////////////////////////////////////////////////////
//                           SIGNUP / REGISTRATION
//////////////////////////////////////////////////////////////////////////*//

export circuit register_account(_accountType: AccountType): Boolean {
  Pausable_assertNotPaused();

  const caller = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
  assert(!Utils_isContractAddress(caller), "HealthPro: contract address not allowed");

  if (disclose(_accountType) == AccountType.PROVIDER) {
     assert(!registeredProviders.member(caller.left), "HealthPro: account already registered as a provider");
     registeredProviders.insert(caller.left);
     AccessControl__grantRole(PROVIDER_ROLE, caller);

     return true;
  }
  else
     if (disclose(_accountType) == AccountType.PATIENT) {
        assert(!registeredPatients.member(caller.left), "HealthPro: account already registered as a patient");
        registeredPatients.insert(caller.left);
        AccessControl__grantRole(PATIENT_ROLE, caller);

        return true;
     }
     else {
        return false;
     }
}

//*//////////////////////////////////////////////////////////////////////////
//                          HEALTH RECORD MANAGEMENT
//////////////////////////////////////////////////////////////////////////*//

export circuit storeHealthRecord(record: Opaque<"string">, recordType: RecordType): [] {
  Pausable_assertNotPaused();

  const caller = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
  assert(registeredPatients.member(caller.left), "HealthPro: caller not registered as a patient");
  healthRecords.insert(caller.left, disclose(record));
}

export circuit grantProviderAccess(provider: ZswapCoinPublicKey): [] {
  Pausable_assertNotPaused();

  const caller = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
  assert(registeredPatients.member(caller.left), "HealthPro: caller not registered as a patient");
  assert(registeredProviders.member(disclose(provider)), "HealthPro: target account not registered as a provider");

  const commitment = commitments.lookup(disclose(caller.left));
  const keyDigest = reveal_private_key(provider.bytes as Field as Uint<32>);
}

//*//////////////////////////////////////////////////////////////////////////
//                              ADMIN FUNCTIONS
//////////////////////////////////////////////////////////////////////////*//

export circuit pause(): [] {
  AccessControl_assertOnlyRole(AccessControl_DEFAULT_ADMIN_ROLE);
  Pausable__pause();
}

export circuit unpause(): [] {
  AccessControl_assertOnlyRole(AccessControl_DEFAULT_ADMIN_ROLE);
  Pausable__unpause();
}

//*//////////////////////////////////////////////////////////////////////////
//                              HELPER CIRCUITS
//////////////////////////////////////////////////////////////////////////*//

// Compute hash of user's private key
export circuit compute_key_digest(privateKey: Bytes<32>): Bytes<32> {
  return persistentHash<Bytes<32>>(privateKey);
}

// Compute commitment: hash of userID and keyDigest
export circuit compute_commitment(account: Uint<32>, keyDigest: Bytes<32>): Bytes<32> {
  return persistentHash<[Uint<32>, Bytes<32>]>([account, keyDigest]);
}

// Compute an auth proof by domain-separating (namespacing) and hashing the commitment, randomChallenge, and keyDigest
//  so the contract can recompute and verify client proofs
export circuit compute_auth_proof(commitment: Bytes<32>, randomChallenge: Bytes<32>, // random nonce
                                  keyDigest: Bytes<32>): Bytes<32> {
  // create a tag so other hashes canâ€™t collide
  const tag = pad(32, "healthpro:auth");
  return persistentHash<[Bytes<32>, Bytes<32>, Bytes<32>, Bytes<32>]>(
           [tag, commitment, randomChallenge, keyDigest]);
}

// Computes the expected data-integrity proof by domain-separating (namespacing) and hashing commitment, plaintext hash,
//  ciphertext hash, and keyDigest so the contract can recompute and verify client proofs
export circuit compute_integrity_proof(
                 commitment: Bytes<32>, unencryptedHash: Bytes<32>, // off-chain calculated hash
                 encryptedHash: Bytes<32>, // hash of the ciphertext transmitted off-chain
                 keyDigest: Bytes<32>): Bytes<32> {
  const tag = pad(32, "healthpro:integ");
  return persistentHash<[Bytes<32>, Bytes<32>, Bytes<32>, Bytes<32>, Bytes<32>]>(
           [tag, commitment, unencryptedHash, encryptedHash, keyDigest]);
}
